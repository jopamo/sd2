# sd2 CLI Option Guide

Below is a full v1 CLI option guide for `sd2`.

## Synopsis

```bash
# Replace in explicit files
sd2 [OPTIONS] FIND REPLACE [FILES...]

# Replace in files listed on stdin (fd/rg -l output)
fd -e rs | sd2 [OPTIONS] FIND REPLACE
rg -l PATTERN | sd2 [OPTIONS] FIND REPLACE

# Targeted edits using rg JSON matches
rg --json PATTERN | sd2 --rg-json [OPTIONS] FIND REPLACE

# Agent workflow
sd2 schema
sd2 apply --manifest manifest.json [OPTIONS]
```

---

## Commands

### Default command: `sd2 FIND REPLACE [FILES...]`

Edits the provided files, or reads file paths from stdin when no files are passed.

### `schema`

Print the JSON Schema describing manifests, operations, and output events.

```bash
sd2 schema > tools_schema.json
```

### `apply --manifest FILE`

Apply a manifest (multi-file, multi-op), with full validation and atomic commit.

```bash
sd2 apply --manifest manifest.json
```

---

## Input modes

`sd2` is strict about what stdin means.

### Auto (default)

If stdin is piped **and** no `FILES...` are given, stdin is treated as a list of paths (newline-delimited).

```bash
rg -l unwrap | sd2 unwrap expect
fd -e rs | sd2 foo bar
```

### `--stdin-paths`

Force stdin to be interpreted as newline-delimited paths.

### `--files0`

Read **NUL-delimited** paths from stdin (for `fd -0`, `find -print0`, etc).

```bash
fd -0 -e rs | sd2 --files0 foo bar
```

### `--stdin-text`

Treat stdin as *content* and write the transformed content to stdout (filter mode).
No files are opened.

```bash
printf '%s\n' "hello foo" | sd2 --stdin-text foo bar
```

### `--rg-json`

Consume `rg --json` output from stdin and apply edits only to the matched spans.

```bash
rg --json "foo" | sd2 --rg-json foo bar
```

Rules:

* no re-searching
* edits are constrained to rg-reported match spans
* fails if input is not rg JSON

### `--files`

Force positional arguments to be treated as files even if stdin is present.
Useful when a previous command in a pipeline accidentally feeds stdin.

---

## Match semantics

### Literal by default

`FIND` is treated as an exact string.

### `--regex`

Treat `FIND` as a regex pattern.

```bash
sd2 --regex 'foo\s+bar' 'baz' file.txt
```

### Case handling

* `--case-sensitive` default
* `--ignore-case`
* `--smart-case` (case-insensitive unless `FIND` contains uppercase)

---

## Scope controls

### `--limit N`

Maximum replacements per file.

```bash
sd2 foo bar file.rs --limit 1
```

### `--range START[:END]`

Only apply replacements in a line range (1-based).

```bash
sd2 foo bar file.rs --range 10:200
sd2 foo bar file.rs --range 40
```

### `--glob-include GLOB`

Apply edits only to files whose *path* matches the glob.
This is not traversal logic, itâ€™s a post-filter on the incoming file list.

```bash
fd . | sd2 foo bar --glob-include '**/*.rs'
```

### `--glob-exclude GLOB`

Exclude matching paths (post-filter).

---

## Safety and guarantees

### `--dry-run`

Print a unified diff, perform no writes.

```bash
sd2 foo bar src/main.rs --dry-run
```

### `--no-write`

Stronger than `--dry-run`: still does parsing, matching, planning, and validation, but guarantees zero filesystem writes even if output mode changes.

### `--require-match`

Fail if **zero** matches are found across all inputs.

### `--expect N`

Require **exactly N total replacements** across all inputs.
If the count differs, abort and write nothing.

### `--fail-on-change`

Exit non-zero if any change would occur (CI assertions).

---

## Transaction model

### `--transaction all|file`

* `all` (default): stage edits and commit only if every file succeeds
* `file`: commit each file independently (still atomic per file)

---

## Filesystem behavior

### `--symlinks follow|skip|error`

* `follow` (default): edit the target file and preserve the symlink
* `skip`: ignore symlink paths
* `error`: abort if any symlink is encountered

### `--binary skip|error`

* `skip` (default): skip binary-like files silently or with a warning event
* `error`: abort if a binary-like file is encountered

### `--permissions preserve|fixed`

* `preserve` (default): preserve mode/owner where possible
* `fixed`: write with a fixed mode (used mainly in controlled environments)

---

## Output control

### Default output behavior

* TTY: unified diff + summary
* Pipe: JSON events (machine-friendly)

### `--json`

Force JSON event output even on a TTY.

### `--quiet`

No diff, no summary. Errors still emitted.

### `--format diff|summary|json`

Explicit output formatting.

---

## Agent/manifest options

### `apply --manifest FILE`

Reads and validates the manifest, runs operations, and commits atomically.

Options:

* `--validate-only` parse + validate + plan, no execution
* `--dry-run` diff output for the planned changes
* `--json` emit structured events

---

## Exit codes

* `0` success (and no policy violations)
* `1` operational failure (I/O, parse errors, invalid args)
* `2` policy failure (`--require-match`, `--expect`, `--fail-on-change`)
* `3` partial/aborted transaction (should only happen with `--transaction file`)
